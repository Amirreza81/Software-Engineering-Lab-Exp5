# Software-Engineering-Lab-Exp5

## بخش اول - پروفایلینگ JavaCup
در ابتدا کد JavaCup را با استفاده از YourKit ران کرده و Profiling را انجام می دهیم. ابتدا مشاهده می شود که برنامه تا آخر اجرا نشده است و ارور OutOfMemory داده است:

![photo_2025-05-12_11-59-58](https://github.com/user-attachments/assets/8a59ad6c-3e8c-4756-a4bf-f68e521bb513)

سپس آنالیز را با استفاده از YourKit انجام می دهیم. با توجه به داده های گزارش شده می توان فهمید که تابع temp بیشترین میزان مصرف را دارد و باعث ارور دادن برنامه می شود:

![photo_2025-05-12_12-00-49](https://github.com/user-attachments/assets/0bbf2ba1-5a46-45af-8e27-b5d54ba0ef40)


![photo_2025-05-12_12-01-05](https://github.com/user-attachments/assets/88ca3069-673a-41c5-9573-97677f83f091)


![photo_2025-05-12_12-01-12](https://github.com/user-attachments/assets/b09f9362-aebc-4c47-a6eb-9f9a1b51f37f)


![photo_2025-05-12_12-01-16](https://github.com/user-attachments/assets/215c723d-63af-49fd-835d-96a4055dec08)


در این تابع، یک ArrayList به نام a ایجاد می‌شود که در هر بار اجرای حلقه‌های تو در تو، برای هر ترکیب از i و j یک مقدار جدید به آن افزوده می‌شود. این فرآیند باعث ایجاد تعداد زیادی شیء و افزایش غیرضروری در مصرف حافظه و زمان پردازش می‌گردد. زیرا ArrayList به صورت پویا عمل می‌کند و با هر بار افزودن عنصر جدید، ممکن است نیاز به تخصیص حافظه‌ی تازه‌ای داشته باشد. زمانی که تعداد تکرارها زیاد باشد، این تخصیص‌های مکرر حافظه و گسترش پیاپی ظرفیت لیست، منجر به مصرف زیاد منابع و کاهش کارایی کلی برنامه می‌شود. بنابراین با این متد پیش رفتن باعث پر شدن حافظه و ارور OutOfMemory می شود:

![Screenshot 2025-05-12 121847](https://github.com/user-attachments/assets/374bbe60-e6e6-44b1-b005-6fc61d1e623e)

برای بهینه‌سازی مصرف منابع، به جای استفاده از ArrayList که به‌صورت پویا حافظه را مدیریت می‌کند، می‌توان از یک آرایه‌ی دوبعدی با اندازه‌ی مشخص استفاده کرد. این روش باعث می‌شود حافظه از ابتدا به‌طور کامل تخصیص داده شود و نیازی به افزایش تدریجی ظرفیت یا جابجایی داده‌ها در حافظه نباشد. در نسخه بهینه‌شده، یک آرایه‌ی دوبعدی از نوع int با ابعاد ۲۰۰۰۰ در ۱۰۰۰۰ تعریف شده است، که هر مقدار مستقیماً در مکان مناسب خود در آرایه قرار می‌گیرد. با این کار، مدیریت حافظه ساده‌تر و کارآمدتر می‌شود و از سربار ناشی از ساختارهای داینامیک جلوگیری خواهد شد:

![photo_2025-05-12_12-01-20](https://github.com/user-attachments/assets/8e1d2484-91fd-4e38-899c-a061a3e8185e)


حال دوباره عمل Profiling را انجام می دهیم. در ابتدا مشاهده می شود که برنامه تا انتها اجرا شده است:

![photo_2025-05-12_12-01-23](https://github.com/user-attachments/assets/e2ff4a61-8464-4feb-9f47-9478f83478bb)

همچنین با استفاده از YourKit می توان مشاهده کرد مقدار استفاده از منابع نیز بسیار کاهش یافته است:

![photo_2025-05-12_12-01-26](https://github.com/user-attachments/assets/a7c9efde-fa29-4232-adfa-ec95659715e5)


![photo_2025-05-12_12-01-30](https://github.com/user-attachments/assets/98903a19-f2b0-4057-a436-e9328735d8b8)


![photo_2025-05-12_12-01-33](https://github.com/user-attachments/assets/9200250f-02b6-474a-be81-fa31e909c134)



